#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

#include "tinyxml2.h"
#include "Matrix.h"

#include <sstream>
#include <vector>
#include <algorithm>
#include <list>
#include <fstream>

using namespace tinyxml2;

const float TILE_SIZE = 20.f;

struct ObsRow
{
	ObsRow() {}
	ObsRow(unsigned xx, unsigned yy, unsigned l) : x(xx), y(yy), len(l) {}
	inline bool operator<(const ObsRow& o) const
	{
		return y < o.y || (y == o.y && x < o.x);
	}
	unsigned x, y, len;
};

struct Pos
{
	Pos() {}
	Pos(unsigned xx, unsigned yy) : x(xx), y(yy) {}
	unsigned x, y;
};

int main(int argc, char **argv)
{
	if(argc < 3)
	{
		puts("aqnavmapgen <infile> <outfile>");
		return 2;
	}

	XMLDocument doc;
	XMLError err = doc.LoadFile(argv[1]);
	if(err != XML_NO_ERROR)
	{
		printf("Error opening XML file: %d\n", err);
		return 1;
	}

	XMLElement *obs = doc.FirstChildElement("Obs");
	if(!obs)
		return 3;

	unsigned maxx = 0;
	std::vector<ObsRow> rows;
	{
		ObsRow row;
		std::istringstream is(obs->Attribute("d"));
		while (is >> row.x)
		{
			is >> row.y >> row.len;
			rows.push_back(row);
			maxx = std::max(maxx, row.x + row.len + 1);
		}
	}
	if(rows.empty())
		return 4;

	std::sort(rows.begin(), rows.end());
	unsigned maxy = rows.back().y + 1;
	printf("Map size: %dx%d\n", maxx, maxy);
	Matrix<int> map(maxx, maxy);
	for(unsigned y = 0; y < maxy; ++y)
		for(unsigned x = 0; x < maxx; ++x)
			map(x, y) = -1;
	
	for(size_t i = 0; i < rows.size(); ++i)
	{
		ObsRow r = rows[i];
		const unsigned lim = r.x + r.len + 1;
		for(unsigned x = r.x; x < lim; ++x)
			map(x, r.y) = 0;
	}
	
	int region = 0;
	std::list<Pos> todo;
	for(unsigned y = 0; y < maxy; ++y)
		for(unsigned x = 0; x < maxx; ++x)
			if(map(x, y) == -1)
			{
				++region;
				todo.push_back(Pos(x, y));
				do
				{
					Pos p = todo.front();
					todo.pop_front();

					if(map(p.x, p.y) == -1)
					{
						map(p.x, p.y) = region;
						#define CHECK(X, Y) do { if(unsigned(X) < maxx && unsigned(Y) < maxy) todo.push_back(Pos((X),(Y))); } while(0)
						CHECK(p.x - 1, p.y);
						CHECK(p.x + 1, p.y);
						CHECK(p.x, p.y - 1);
						CHECK(p.x, p.y + 1);
						#undef CHECK
					}
				}
				while(todo.size());
			}

#ifdef _DEBUG
	{
		unsigned char * const buf = (unsigned char*)malloc(maxx*maxy);
		unsigned char *p = buf;
		for(unsigned y = 0; y < maxy; ++y)
			for(unsigned x = 0; x < maxx; ++x)
			{
				const int v = map(x, y);
				assert(v != -1);
				*p++ = v == 0 ? 0 : (255 - 16 * v);
			}
		stbi_write_png((std::string(argv[2]) + ".png").c_str(), maxx, maxy, 1, buf, maxx);
		free(buf);
	}
#endif
	
	std::vector<std::vector<Pos> > open(maxy);
	unsigned openlines = 0;
	unsigned linemax = 0;
	for(unsigned y = 0; y < maxy; ++y)
	{
		int cur = map(0, y);
		unsigned x = 0;
		do
		{
			unsigned start = -1;
			while(start == -1 && x < maxx)
				if(map(x, y))
					start = x;
				else
					++x;
			while(x < maxx && map(x, y))
				++x;
			unsigned last = x - 1; // inclusive
			if(start != -1 && last != -1) // start == last means 1 block wide
			{
				assert(map(start, y) > 0);
				assert(map(last, y) > 0);
				open[y].push_back(Pos(start, last));
				++openlines;
			}
		}
		while (x < maxx);
		linemax = std::max(linemax, open[y].size());
	}
	printf("open lines: %u; linemax: %u\n", openlines, linemax);

	std::vector<unsigned> S, E, R, I(maxy), N(maxy);

	for(unsigned y = 0; y < maxy; ++y)
	{
		const std::vector<Pos>& row = open[y];
		const unsigned sz = (unsigned)row.size();
		I[y] = unsigned(S.size());
		N[y] = sz;

		for(unsigned i = 0; i < sz; ++i)
		{
			Pos p = row[i];
			S.push_back(p.x);
			E.push_back(p.y);
			int v = map(p.x, y);
			assert(v > 0);
			R.push_back(v);
		}
	}

	std::ofstream os(argv[2]);
	if(!os)
	{
		puts("Failed to write output file");
		return 5;
	}
	os << "-- AUTOGENERATED, DO NOT EDIT\nreturn {\n";
	for(size_t i = 0; i < S.size(); ++i)
		os << S[i] << ","; // from left edge of block...
	os << "\n},{\n";
	for(size_t i = 0; i < E.size(); ++i)
		os << E[i] << ","; // ... to right edge of block
	os << "\n},{\n";
	for(size_t i = 0; i < R.size(); ++i)
		os << R[i] << ",";
	os << "\n},{\n";
	for(size_t i = 0; i < I.size(); ++i)
		os << (N[i] ? (I[i]+1) : 0) << ","; // convert to 1-based Lua index. Also tiny optimization: Can skip if this is 0
	os << "\n},{\n";
	for(size_t i = 0; i < N.size(); ++i)
		os << N[i] << ",";
	os << "\n}\n";

	os.close();

	return 0;
}
